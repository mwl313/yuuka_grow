import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { ENDING_META, type Lang } from "../src/shared/endingMeta.ts";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");

const START_MARKER = "  // <AUTO-GENERATED ENDING META START>";
const END_MARKER = "  // <AUTO-GENERATED ENDING META END>";
const LEGACY_START_MARKER = "  // <AUTO-GENERATED ENDING TITLES START>";
const LEGACY_END_MARKER = "  // <AUTO-GENERATED ENDING TITLES END>";
const META_BLOCK_NOTE =
  "  // Do not edit ending meta here. Edit src/shared/endingMeta.ts and run i18n sync.";

const LOCALE_PATHS: Record<Lang, string> = {
  ko: path.join(projectRoot, "src", "i18n", "locales", "ko.ts"),
  en: path.join(projectRoot, "src", "i18n", "locales", "en.ts"),
  ja: path.join(projectRoot, "src", "i18n", "locales", "ja.ts"),
};

function escapeForTs(value: string): string {
  return JSON.stringify(value);
}

function buildGeneratedInner(lang: Lang): string {
  const endingIds = Object.keys(ENDING_META[lang]).sort((a, b) => a.localeCompare(b));
  const lines = [META_BLOCK_NOTE];
  for (const endingId of endingIds) {
    const entry = ENDING_META[lang][endingId];
    lines.push(`  ${escapeForTs(`ending.${endingId}.title`)}: ${escapeForTs(entry.title)},`);
    lines.push(`  ${escapeForTs(`ending.${endingId}.condition`)}: ${escapeForTs(entry.condition)},`);
  }
  return lines.join("\n");
}

function insertMarkerBlock(content: string, generatedInner: string): string {
  const block = `${START_MARKER}\n${generatedInner}\n${END_MARKER}\n`;
  const anchor = '  "ending.continue":';
  const anchorIndex = content.indexOf(anchor);
  if (anchorIndex !== -1) {
    return `${content.slice(0, anchorIndex)}${block}${content.slice(anchorIndex)}`;
  }

  const exportAnchor = "\nexport default ";
  const exportIndex = content.indexOf(exportAnchor);
  if (exportIndex !== -1) {
    return `${content.slice(0, exportIndex)}\n${block}${content.slice(exportIndex)}`;
  }

  return `${content}\n${block}`;
}

function removeExistingAutoBlock(content: string): string {
  const blocks: Array<{ start: string; end: string }> = [
    { start: START_MARKER, end: END_MARKER },
    { start: LEGACY_START_MARKER, end: LEGACY_END_MARKER },
  ];

  let output = content;
  for (const block of blocks) {
    const startIndex = output.indexOf(block.start);
    const endIndex = output.indexOf(block.end);
    if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
      continue;
    }
    const endWithMarker = endIndex + block.end.length;
    const afterBlock = output.slice(endWithMarker).replace(/^\r?\n/, "");
    const beforeBlock = output.slice(0, startIndex).replace(/\s*$/, "");
    output = `${beforeBlock}\n${afterBlock}`;
  }
  return output;
}

function removeManualEndingMetaLines(content: string): string {
  const endingMetaLine = /^\s*"ending\.[^"]+\.(title|condition)":\s*".*",\s*\r?\n/gm;
  return content.replace(endingMetaLine, "");
}

function upsertEndingTitleBlock(content: string, lang: Lang): string {
  const generatedInner = buildGeneratedInner(lang);
  const withoutOldBlock = removeExistingAutoBlock(content);
  const stripped = removeManualEndingMetaLines(withoutOldBlock);
  return insertMarkerBlock(stripped, generatedInner);
}

function syncLocale(lang: Lang): void {
  const filePath = LOCALE_PATHS[lang];
  const original = fs.readFileSync(filePath, "utf8");
  const updated = upsertEndingTitleBlock(original, lang);
  if (updated !== original) {
    fs.writeFileSync(filePath, updated, "utf8");
    console.log(`synced ending meta: ${path.relative(projectRoot, filePath)}`);
  } else {
    console.log(`ending meta unchanged: ${path.relative(projectRoot, filePath)}`);
  }
}

function main(): void {
  const languages: Lang[] = ["ko", "en", "ja"];
  for (const lang of languages) {
    syncLocale(lang);
  }
}

main();
