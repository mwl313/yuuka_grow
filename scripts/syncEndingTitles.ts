import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { ENDING_TITLES, type Lang } from "../src/shared/endingTitles.ts";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");

const START_MARKER = "  // <AUTO-GENERATED ENDING TITLES START>";
const END_MARKER = "  // <AUTO-GENERATED ENDING TITLES END>";
const TITLE_BLOCK_NOTE =
  "  // Do not edit ending titles here. Edit src/shared/endingTitles.ts and run i18n sync.";

const LOCALE_PATHS: Record<Lang, string> = {
  ko: path.join(projectRoot, "src", "i18n", "locales", "ko.ts"),
  en: path.join(projectRoot, "src", "i18n", "locales", "en.ts"),
  ja: path.join(projectRoot, "src", "i18n", "locales", "ja.ts"),
};

function escapeForTs(value: string): string {
  return JSON.stringify(value);
}

function buildGeneratedInner(lang: Lang): string {
  const endingIds = Object.keys(ENDING_TITLES[lang]).sort((a, b) => a.localeCompare(b));
  const lines = [TITLE_BLOCK_NOTE];
  for (const endingId of endingIds) {
    const key = `ending.${endingId}.title`;
    const value = ENDING_TITLES[lang][endingId];
    lines.push(`  ${escapeForTs(key)}: ${escapeForTs(value)},`);
  }
  return lines.join("\n");
}

function insertMarkerBlock(content: string, generatedInner: string): string {
  const block = `${START_MARKER}\n${generatedInner}\n${END_MARKER}\n`;
  const anchor = '  "ending.continue":';
  const anchorIndex = content.indexOf(anchor);
  if (anchorIndex !== -1) {
    return `${content.slice(0, anchorIndex)}${block}${content.slice(anchorIndex)}`;
  }

  const exportAnchor = "\nexport default ";
  const exportIndex = content.indexOf(exportAnchor);
  if (exportIndex !== -1) {
    return `${content.slice(0, exportIndex)}\n${block}${content.slice(exportIndex)}`;
  }

  return `${content}\n${block}`;
}

function removeExistingAutoBlock(content: string): string {
  const startIndex = content.indexOf(START_MARKER);
  const endIndex = content.indexOf(END_MARKER);
  if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) return content;
  const endWithMarker = endIndex + END_MARKER.length;
  const afterBlock = content.slice(endWithMarker).replace(/^\r?\n/, "");
  const beforeBlock = content.slice(0, startIndex).replace(/\s*$/, "");
  return `${beforeBlock}\n${afterBlock}`;
}

function removeManualEndingTitleLines(content: string): string {
  const endingTitleLine = /^\s*"ending\.[^"]+\.title":\s*".*",\s*\r?\n/gm;
  return content.replace(endingTitleLine, "");
}

function upsertEndingTitleBlock(content: string, lang: Lang): string {
  const generatedInner = buildGeneratedInner(lang);
  const withoutOldBlock = removeExistingAutoBlock(content);
  const stripped = removeManualEndingTitleLines(withoutOldBlock);
  return insertMarkerBlock(stripped, generatedInner);
}

function syncLocale(lang: Lang): void {
  const filePath = LOCALE_PATHS[lang];
  const original = fs.readFileSync(filePath, "utf8");
  const updated = upsertEndingTitleBlock(original, lang);
  if (updated !== original) {
    fs.writeFileSync(filePath, updated, "utf8");
    console.log(`synced ending titles: ${path.relative(projectRoot, filePath)}`);
  } else {
    console.log(`ending titles unchanged: ${path.relative(projectRoot, filePath)}`);
  }
}

function main(): void {
  const languages: Lang[] = ["ko", "en", "ja"];
  for (const lang of languages) {
    syncLocale(lang);
  }
}

main();
